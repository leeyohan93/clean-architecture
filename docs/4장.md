## 04. 유스케이스 구현하기

### 유스케이스 둘러보기

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

### 입력 유효성 검증

애플리케이션 계층에서 입력 유효성을 검증해야 한다.

그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다.

하지만 입력 유효성 검증은 유스클래스의 책임이 아니면 **입력모델(input model)**이 책임을 할당하면 유효성 검증이 애플리케이션의 코어에 남아있지만 신성한 유스케이스 코드를 오염시키지는 않는다.

이런 귀찮은 작업은 자바의 Bean Validation API를 사용하면 쉽게 구현할 수 있다.

### 유스케이스마다 다른 입력 모델

각기 다른 유스케이스에 동일한 입력 모델을 사용하고 싶은 생각이 들 때가 있다.

(ex. `계좌 등록하기`, `계좌 정보 업데이트하기` )

하지만 동일한 입력모델을 사용하게 되면 불변 커맨드 객체의 필드에 대해서 null을 유효한 상태로 받아들이게 되고, 그 자체가 코드 냄새다. 하지만 더 문제가 되는 부분은 입력 유효성 검증을 어떻게 검증하느냐이다.

등록 유스케이스와 업데이트 유스케이스는 서로 다른 유효성 검증 로직이 필요하기 때문에, 유효성 검증이 유스케이스로 오염될 가능성이 있다.

각 유스케이스 전용 입력모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과를 발생하지 않게 한다.

### 비즈니스 규칙 검증하기

입력 유효성 검증은 유스케이스 로직의 일부가 아닌 반면, 비즈니스 규칙 검증은 분명히 유스케이스 로직의 일부다.

입력 유효성을 검증하는 것은 **구문상(syntactical)의** 유효성을 검증하는 것이라고 할 수 있고, 비즈니스 규칙은 유스케이스의 맥락속에서 **의미적인(semantical)** 유효성을 검증하는 일이라고 할 수 있다.

비즈니스 규칙과 입력 유효성을 구분하는 기준은 모델의 현재 상태에 접근해야 하는지 여부로 알 수 있다.

비즈니스 규칙 검증은 아래와 같이 두가지 방법으로 처리할 수 있다.

1. 도메인 엔티티 내부
2. 유스케이스에서 검증

### 풍부한 도메인 모델 vs. 빈약한 도메인 모델

이 책의 아키텍처 스타일은 도메인 모델을 구현하는 방벙에 대해서는 열려 있다.

> 개인적으로 항상 풍부한 도메인 모델을 선호한다. 유스케이스에 모두 구현하는 방법은 테스트가 어렵다.
>

### 유스케이스마다 다른 출력 모델

입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋다. 출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다.

유스케이스들 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다. 한 유스케이스에서 출력 모델에 새로운 필드가 필요해지면 다른 유스케이스에서도 이 필드를 처리해야 한다. 공유 모델은 장기적으로 봤을 때 갖가지 이유로 점점 커지게 돼 있다.

같은이유로 도메인 엔티티르 출력모델에 사용하고 싶은 유혹도 견뎌야 한다.

### 읽기 전용 유스케이스는 어떨까?

애플리케이션 코어의 관점에서 해당 작업이 간단한 데이터 쿼리이고, 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해 쿼리로 구현할 수 있다.

이를 구현하는 한가지 방법은 쿼리를 위한 인커밍 전용 포트를 만들고 이를 `쿼리 서비스`에 구현하는 것이다.

```java
package buckpal.account.application.service;

@RequiredArgsConstructor
class GetAccountBalanceService implements GetAccountBalanceQuery {

	private final LoadAccountPort loadAccountPort;

	@Override
	public Money getAccountBalance(AccountId accountId) {
		return loadAccountPort.loadAccount(accountId, LocalDateTime.now())
				.calculateBalance();
	}
}
```

쿼리 서비스는 유스케이스 서비스와 동일한 방식으로 동작한다. 이런 방식은 CQS나 CQRS 같은 개념과 아주 잘 맞는다.

### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

입출력 모델을 독립적으로 모델링한다면 원치 않는 부수효과를 피할 수 있다.

물론 모델을 공유하는 것보다 더 많은 작업이 필요하다. 그러나 유스케이스별로 모델을 만들면 유스케이스를 명확하게 이해할 수 있고, 장기적으로 유지보수하기도 더 쉽다. 여러 명의 개발자가 동시에 여러 개의 유스케이스로 동시 작업을 할 수도 있다.