## 01. 계층형 아키텍처의 문제는 무엇일까?

---

### 계층형 아키텍쳐

![전통적인 웹 어플리케이션 구조](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fafa7788-abbb-4980-870d-4e6a3118ffa4/스크린샷_2022-01-06_오전_10.51.03.png)

전통적인 웹 어플리케이션 구조

- 웹 계층: 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청
- 도메인 계층: 필요한 비즈니스 로직을 수행, 영속성 컴포넌트 호출
- 영속성 계층: 도메인 엔티티의 현재 상태를 조회하거나 변경

위와 같은 계층형 아키텍처는 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수 많은 허점들을 노출한다.

### 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

정의에 따르면 전통적인 계층형 아키텍처의 토대는 데이터베이스다.

우리는 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다. 어떤 애플리케이션이든 상태가 중요한 요소이긴 하지만 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다.

그렇다면 우리는 왜 ‘도메인 로직’ 이 아닌 ‘데이터 베이스’를 토대로 아키텍처를 만드는걸까 ?

1. **데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현**

의존성의 방향에 따라 자연스럽게 구현한 이 방법은 합리적인 방법인 것 처럼 보이지만, 비즈니스 관점에서는 전혀 맞지 않는 방법이다. 다른 무엇보다 도메인 로직을 먼저 만들어야 하며 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야한다.

1. **ORM 프레임워크 사용**

ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

![도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fc0a8e88-6506-4a54-aa9e-e9d1ea7b2e74/스크린샷_2022-01-07_오전_10.30.52.png)

도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다.

그림과 같이 ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다. 계층은 아래방향으로 접근 가능하기 때문에 이러한 엔티티에 접근할 수 있다면 분명 사용되기 마련이다.

하지만 이렇게 되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생기게 되는데, 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시로딩 / 지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업을 해야한다.

영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘 중 하나만 바꾸는 것이 어려워지는데, 이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.

### 지름길을 택하기 쉬워진다

전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.

따라서 만약 하위 계층에서 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 계층 아래 계층으로 내려버리면 된다. 그러면 접근 가능하게 되고, 깔끔하게 문제가 해결된다.

하지만 이러한 지름길을 사용하게 되면`깨진 유리창 이론`과 같은 상황이 벌어진다. 결국 하위 계층에서는 모든 것에 접근이 가능하도록 만들어질 수 있으며 시간이 지나면서 점점 더 비대해질 것이다.

그러니 이러한 지름길을 택하지 않으려면 코드 리뷰와 같은 방안 보다는 빌드가 실패하도록 하는 등 강제적인 규칙이 최선의 선택이다.

![영속성 계층에서는 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해진다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4747ed63-abcd-45de-9886-caa97ea4168f/스크린샷_2022-01-07_오전_10.29.10.png)

영속성 계층에서는 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해진다.

### 테스트하기 어려워진다

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너 뛰는 것이다.

예를 들어 엔티티의 필드를 단 하나만 조작하면 되는 경우 웹 계층에서 영속성 계층에 접근하는 것이다.

![스크린샷 2022-01-07 오전 10.38.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d07eacc1-e24d-4ddb-a384-d48f358882de/스크린샷_2022-01-07_오전_10.38.10.png)

1. **도메인 로직을 웹 계층에 구현**

만약 앞으로 유스케이스가 확장된다면 더 많은 도메인 로직이 웹 계층에 추가될 것이고, 이는 핵심 도메인 로직들이 퍼져나갈 확률이 높다. (깨진 유리창 이론)

1. **웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹**

이런 상황은 단위 테스트의 복잡도를 높이고 테스트를 전혀 작성하지 않는 방향으로 가는 첫걸음이다.

### 유스케이스를 숨긴다

기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야 한다. 이런 관점에서 계층형 아키텍처는 어떻게 우리의 발목을 잡을까 ?

![스크린샷 2022-01-08 오후 5.42.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fc5e723-2824-4a70-bfb0-7d45ce4d7a45/스크린샷_2022-01-08_오후_5.42.02.png)

1. **도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.**

이전에 이야기 했던 간단한 유스케이스에서의 계층의 생략이나 특정 컴포넌트를 아래 계층으로 내리는 것이 해당된다.

1. **도메인 서비스의 `너비`에 관한 규칙을 강제하지 않는다.**

넓은 서비스는 많은 의존성을 갖게되고, 많은 웹 레이어의 많은 컴포넌트가 이 서비스를 의존하게 된다. 그럼 서비스를 테스트하기도 어려워지고 작업해야할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

### 동시 작업이 어려워진다

계층형 아키텍처는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인, 웹 계층을 만들어야 한다. 그렇기 때문에 특정 기능은 동시에 한 명의 개발자만 작업할 수 있다.

여러 명의 개발자들이 인터페이스를 먼저 같이 정의하고 인터페이스들로 작업하면 된다고 할 수 도 있다. 물론 가능하지만, 이전에 논의했듯이 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다. 데이터베이스 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여 있기 때문에 쉽지 않다.

코드에 넓은 서비스가 있을 때 또한 병합 추돌(merge conflict)와 같은 이유로 동시에 작업하기 어렵다.

### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, **게층형 아키텍처의 함정을 염두**에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.

### 생각 정리

내가 생각하는 문제들에 대안은 어떤 것일까 ?

1. 데이터베이스 주도 설계 → 도메인 주도 설계
2. 지름길 사용 → 지름길을 택하지 않는 대처 방안 설립
3. 테스트의 어려움 → 레이어 간의 엄격한 구분
4. 유스케이스를 숨김 → 레이어 간의 구분과 적절한 책임의 분리
5. 동시 작업의 어려움 → 도메인 주도 설계