## 03. 코드 구성하기

### 계층으로 구성하기

```
buckpal
├ domain
│	├ Account
│	├ Activity
│	├ AccountRepository
│	├ AccountService
├ persistence
│	├ AccountRepositoryImpl
⎣ web
	⎣ AccountController
```

의존성 역전 원칙으로 의존성이 domain 패키지에 있는 도메인 코드만을 햐하도록 해뒀지만, 아래와 같은 이유로 이 패키지 구조는 최적의 구조가 아니다.

1. 애플리케이션의 기능 조각이나 특성을 구분짓는 패키지 경계가 없다.
2. 어떤 유스케이스들을 제공하는지 파악할 수 없다.
3. 패키지 구조를 통해서는 목표로 하는 아키텍처를 파악할 수 없다.

### 기능으로 구성하기

```
buckpal
⎣ account
	├ Account
	├ AccountController
	├ AccountRepository
	├ AccountRepositoryImpl
	⎣ SendMonepyService

```

계좌와 관련된 모든 코드를 account 패키지로 묶고, 계층 패키지들을 없앴다.

기능에 의한 패키징 방식은 계층으로 구성하는 방식보다 가시성을 훨신 더 떨어뜨린다.

### 아키텍처적으로 표현력 있는 패키지 구조

```
buckpal
⎣ account
	├ adapter
	│	├ in
	│		⎣ web
	│			⎣ AccountController
	│	├ out
	│		⎣ persistence
	│			├ AccountPersistenceAdapter
	│			⎣ SrpingDataAccountRepository
	├ domain
	│	├ Account
	│ ⎣ Activity
	⎣ application
		⎣ SendMoneyService
		⎣ port
			├ in
			│	⎣ SendMoneyUseCase
			⎣ out
				├ LoadAccountPort
				⎣ UpdateAccountStatePort
```

이 패키지 구조는  `아키텍처-코드 갭` 혹은 `모델-코드 갭`을 효과적으로 다룰 수 있는 강력한 요소다. 이러한 용어는 아키텍처가 코드에 직접적으로 매핑될 수 없는 추상적인 개념이란 것을 보여준다. 만약 패키지 구조가 아키텍처를 반영할 수 없다면 시간이 지남에 따라 점점 목표하던 아키텍처로부터 멀어지게 될 것이다.

위 방법이 완벽한 방법은 아니지만 표현력있는 패키지 구조는 적어도 아래와 같은 장점을 가지며 코드와 아키텍처 간의 갭을 줄여준다.

1. 아키텍처에 대한 적극적인 사고를 촉진한다.
2. 우발적인 의존성을 막을 수 있다.
3. DDD 개념(애그리거트)에 직접적으로 대응시킬 수 있다.
4. 어댑터를 다른 구현으로 다른 구현으로 쉽게 교체할 수 있다.

### 의존성 주입의 역할

포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까 ?

이 부분에서 의존성 주입을 활용할 수 있는데, 모든 계층에 의존성을 가진 중립적인 컴포넌트를 도입하는 것이다. 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.

스프링 프레임워크에서는 이 역할을 DI 컨테이너를 통해 하고 있다.

+웹 어댑터와 같이 인커밍 어댑터에 대해서는 의존성의 방향이 같기 때문에 의존성 역전이 필요하지 않다. 그럼에도 불구하고 애플리케이션 계층으로의 진입점을 구분 짓기 위해 실제 서비스를 포트인터페이스들 사이에 숨겨두고 싶을 수 있다.

### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

실제 코드 구조를 최대한 우리가 목표로 하는 아키텍처(육각형 아키텍처)에 가깝게 만들게 되면 얻게 되는 장점들이 많다. 특히 코드에서 아키텍처의 특정 요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다.

- [https://sabarada.tistory.com/159](https://sabarada.tistory.com/159) (DDD 아키텍처)