## 02. 의존성 역전하기

---

1장에서 계층형 아키텍처에 대한 불만의 대안에 대한 이야기

### 단일 책임 원칙

이 원칙의 일반적인 해석은 다음과 같다.

> 하나의 컴포넌트는 오로지 한가지 일만 해야하고, 그것을 올바르게 수행해야 한다.
>

하지만 **책임**은 **오로지 한가지 일만 하는 것**보다는 **변경할 이유**로 해석해야한다.

> 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.
>

만약 컴포넌트를 변경할 이유가 한 가지라면 **우리가 어떤 다른 이유**로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.

변경할 이유가 많이 쌓인 컴포넌트의 구조는 한 컴포넌트를 바꾸는 것이 다른 컴포넌트의 실패하는 원인으로 작용할 수 있는데, 이는 변경에 대한 부수효과(사이드 이펙트)를 우려하게된다.

### 의존성 역전 원칙

계층형 아키텍처에서 계층 간의 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할 때 **상위 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는 것**을 알 수 있다.

> 의존성이란 변경 가능성을 의미하기 때문에, 의존성이 많을 수록 변경 가능성이 높다.
>

의존성 역전 원칙을 이용하면 중요한 비즈니스 로직을 다루는 도메인 코드를 변경에서 보호할 수 있다. 예를 들어 영속성 코드가 바뀐다 하더라도 도메인 코드를 바꾸지 않을 수 있는 것이다.

![스크린샷 2022-01-08 오후 8.37.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da44965c-a1ba-4c18-954a-e931558602ff/스크린샷_2022-01-08_오후_8.37.35.png)

엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.

그러나 이제는 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이의 순환 의존성(circular dependcy)가 생긴다. 이 부분이 바로 DIP를 적용하는 부분이며, 도메인 계층에 리포지토리에 대한 인터페이스를 ㅁ나들고, 실제 리포지토리는 영속성 계층에 구현하게 하는 것이다. 결과는 위와 같다.

> Spring Data JPA에서는 이미 위와 같은 DI를 적용 후의 방법으로 구현되었고, 사용을 권장한다.
>

### 클린 아키텍처

클린 아키텍처에서는 **비즈니스 규칙이 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다**고 이야기했다. 이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미하고 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고 있어야 한다.

![로버트 마틴 - 클린 아키텍처](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a27276e-b650-4c06-9efd-f4501f180828/Untitled.png)

로버트 마틴 - 클린 아키텍처

이 아키텍처의 코어(core)에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 앞에서 서비스라고 불렀던 것들이며 단일 책임을 갖기 위해 더욱 세분화되어 있다. 이를 통해 이전에 이야기했던 넓은 서비스 문제를 피할 수 있다.

클린 아키텍처에는 대가가 따른다. 도메인 계층이 영속성이나 UI와 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야한다. 하지만 이것은 바람직한 일이며, 도메인 코드를 자유롭게 모델링할 수 있고 도메인 주도 설계(DDD)를 가장 순수한 형태로 적용해볼 수도 있다.

클린 아키텍처는 다소 추상적이기 때문에 클린 아키텍처의 원칙들을 조금 더 구체적으로 만들어주는 육각형 아키텍처가 있다.

### 육각형 아키텍처(헥사고날 아키텍처)

![[https://reflectoring.io/spring-hexagonal/](https://reflectoring.io/spring-hexagonal/)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fabc31e3-d721-42e2-9e52-41e4e3d89c9d/Untitled.png)

[https://reflectoring.io/spring-hexagonal/](https://reflectoring.io/spring-hexagonal/)

육각형 내부에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 때문에 클린 아키텍처의 의존성 규칙이 그대로 적용된다.

육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다.

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각 의 포트를 제공해야한다.

- 주도하는 어댑터(driving adaper)의 포트: 유스케이스 클래스들에 의해 구현되고 호출되는 인터페이스
- 주도되는 어댑터(driven adapter)의 포트: 어댑터에 의해 구현, 코어에 의해 호출되는 인터페이스

![육각형 아키텍처를 계층으로 구성해본 그림](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a5eb2dd-1309-4f22-b03e-a2374399a8ff/스크린샷_2022-01-08_오후_9.40.28.png)

육각형 아키텍처를 계층으로 구성해본 그림

### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

클린 아키텍처, 육각형 아키텍터 모두 **의존성을 역전**시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로 의존성을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 그리고 변경할 이유가 적을수록 유지보수성은 더 좋아진다.

도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링될 수 있다.